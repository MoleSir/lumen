
from typing import List, Tuple, Union, Optional, Sequence, Any, Iterator


Scalar = Union[float, int]
TensorLike = Union["Tensor", Scalar]


class DType:
    Float32: "DType"
    Float64: "DType"
    UInt32: "DType"
    Int32: "DType"
    UInt8: "DType"
    Bool: "DType"
    
    def __eq__(self, other: Any) -> bool: ...


class Tensor:
    """
    N-dimensional Tensor library implemented in Rust.
    """
    
    @staticmethod
    def zeros(shape: Sequence[int], dtype: Optional[DType] = None) -> "Tensor":
        ...

    @staticmethod
    def ones(shape: Sequence[int], dtype: Optional[DType] = None) -> "Tensor":
        ...

    @staticmethod
    def rand(
        shape: Sequence[int], 
        min: Optional[float] = 0.0, 
        max: Optional[float] = 1.0, 
        dtype: Optional[DType] = None
    ) -> "Tensor":
        ...

    @staticmethod
    def randn(
        shape: Sequence[int], 
        mean: Optional[float] = 0.0, 
        std: Optional[float] = 1.0, 
        dtype: Optional[DType] = None
    ) -> "Tensor":
        ...

    def dims(self) -> List[int]:
        ...

    def dtype(self) -> DType:
        ...

    def requires_grad(self) -> bool:
        ...

    def set_requires_grad(self, mode: bool) -> None:
        ...

    def __add__(self, other: TensorLike) -> "Tensor": ...
    def __radd__(self, other: TensorLike) -> "Tensor": ...

    def __sub__(self, other: TensorLike) -> "Tensor": ...
    def __rsub__(self, other: TensorLike) -> "Tensor": ...

    def __mul__(self, other: TensorLike) -> "Tensor": ...
    def __rmul__(self, other: TensorLike) -> "Tensor": ...

    def __truediv__(self, other: TensorLike) -> "Tensor": ...
    def __rtruediv__(self, other: TensorLike) -> "Tensor": ...
    
    def __div__(self, other: TensorLike) -> "Tensor": ... 
    def __rdiv__(self, other: TensorLike) -> "Tensor": ...

    def __str__(self) -> str: ...
    def __repr__(self) -> str: ...

    def add(self, other: TensorLike) -> "Tensor": ...
    def sub(self, other: TensorLike) -> "Tensor": ...
    def mul(self, other: TensorLike) -> "Tensor": ...
    def div(self, other: TensorLike) -> "Tensor": ...

    def floor(self) -> "Tensor": ...
    def ceil(self) -> "Tensor": ...
    def round(self) -> "Tensor": ...
    def abs(self) -> "Tensor": ...
    def recip(self) -> "Tensor": ...  
    def sqr(self) -> "Tensor": ... 

    def exp(self) -> "Tensor": ...
    def ln(self) -> "Tensor": ...
    def sin(self) -> "Tensor": ...
    def cos(self) -> "Tensor": ...
    def tanh(self) -> "Tensor": ...
    def sqrt(self) -> "Tensor": ...
    def erf(self) -> "Tensor": ...

    def gelu(self) -> "Tensor": ...
    def gelu_erf(self) -> "Tensor": ...
    def relu(self) -> "Tensor": ...
    def silu(self) -> "Tensor": ...
    def sigmoid(self) -> "Tensor": ...

    def allclose(self, other: "Tensor", rtol: float=1e-5, atol: float=1e-8) -> bool: ...

    def backward(self) -> GradStore: ...


class GradStore:
    def __getitem__(self, index: int) -> Tensor: ...

    def items(self) -> Iterator[Tuple[int, Tensor]]: ...
    def keys(self) -> Iterator[int]: ...
    def values(self) -> Iterator[Tensor]: ...

    def __iter__(self) -> Iterator[int]: ...

    def __len__(self) -> int: ...
